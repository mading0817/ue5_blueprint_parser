# Refactoring Guide: UE5 Blueprint Graph Parser

This document outlines the architectural principles for refactoring the UE5 Blueprint Graph Parser. The primary goal is to create a robust, extensible, and accurate system for converting `.uasset` blueprint text into a human-readable, logical pseudo-code format, primarily for consumption by Large Language Models (LLMs) and developers.

The system is architected as a three-stage pipeline, inspired by modern compiler front-end design.

## Core Architecture: A Three-Stage Pipeline

### 1. Stage One: Graph Construction

*   **Module**: `parser/graph_parser.py`
*   **Input**: Raw Blueprint graph text.
*   **Output**: A `BlueprintGraph` object.
*   **Responsibility**: This stage is responsible for a high-fidelity, lossless conversion of the raw text into a foundational graph data structure. It parses all nodes, pins, and their explicit `LinkedTo` connections without interpreting their logical meaning. The output is a complete, raw representation of the blueprint's structure.

### 2. Stage Two: Logical AST Generation (New Architecture)

*   **Module**: `parser/analyzer.py` (with `parser/symbol_table.py`)
*   **Input**: The `BlueprintGraph` object from Stage One.
*   **Output**: A **Semantically-Rich, Context-Aware, Logical Abstract Syntax Tree (AST)**.
*   **Responsibility**: This stage is the heart of the parser. It has been redesigned to overcome the limitations of the previous model, which led to systemic errors like `UnknownFunction` and `UnknownDelegate`. The new architecture is founded on a **"Unified Resolution Model"**.

#### Core Principles of the New Architecture:

1.  **Unified Resolution Model**:
    *   The previous separation of `_follow_execution_flow` and `_resolve_data_expression` was a critical flaw, as it failed to model the intertwined nature of execution and data flow in Blueprints.
    *   **Solution**: We've introduced a single, higher-order resolution function: `resolve(pin) -> ResolutionResult`. This function returns both the sequence of statements triggered by an execution pin and the data value expression produced by a data pin. This elegantly models how a single Blueprint node can both perform an action and yield a result.

2.  **Context-Aware AST with Bidirectional Linking**:
    *   Previously, the AST was a simple tree, and the Symbol Table was an external tool. This made it difficult to understand a node's context.
    *   **Solution**: The Symbol Table is now a tree of `Scope` objects, each corresponding to a lexical scope (like a loop body or an event callback). Crucially, every `ASTNode` now holds a direct reference to the `Scope` it belongs to, and each `Scope` references the `ASTNode` that created it. This creates a self-contained, context-aware AST where any node's full environment can be easily introspected.

3.  **Enhanced AST Semantics for Complex Patterns**:
    *   To address the root cause of parsing failures, the AST (`parser/models.py`) has been upgraded to express complex Blueprint patterns natively:
        *   **`PropertyAccessNode`**: Enables the representation of nested property access chains (e.g., `Variable.Member.SubMember`), which is critical for correctly parsing component and object interactions.
        *   **`AssignmentNode.target: Expression`**: The left-hand side of an assignment is no longer a simple string but a full expression. This allows for complex assignments like `MyButton.OnClicked = MyEvent`, which was previously impossible.
        *   **`EventReferenceExpression`**: A dedicated AST node to represent a reference to a bindable event, distinguishing it semantically from a function call.
        *   **`LoopVariableExpression`**: NEW   A first-class node used to represent iterator variables generated by loop-style macros (e.g. `ArrayElement`, `ArrayIndex`, `LoopCounter`). This removes the need for fragile string matching and guarantees that any macro-defined variable is resolved in the AST phase instead of degrading to `UnknownFunction` placeholders.

This new architecture replaces the previous, fragile approach, ensuring that the parsing process is robust, maintainable, and correctly interprets the complex interplay of execution, data flow, scope, and bindings within UE Blueprints.

### 3. Stage Three: AST Formatting

*   **Module**: `parser/formatters.py` (requires updates)
*   **Input**: The new, semantically-rich Logical AST from Stage Two.
*   **Output**: A formatted string (e.g., Markdown pseudo-code).
*   **Responsibility**: This stage translates the logical AST into a final textual representation. It must be updated to support the new AST nodes (`PropertyAccessNode`, `EventReferenceExpression`, etc.) to correctly render the new, more complex structures.
    *   **Visitor Pattern**: Formatters will continue to be implemented as visitors that traverse the AST. This decoupling of logic from presentation remains a core design principle.
